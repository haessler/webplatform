

=Core APIs=

===ooo Level 3 CSS Selectors===

Level 3 CSS provides many useful new '''selectors''' that make it
easier to apply formatting to page elements. These selectors are
useful not only in applying style sheets, but when manipulating
elements with JavaScript.

The '''Selectors API''' makes DOM elements accessible using the same
CSS expressions you use to apply formatting to them. The following
show alternate ways to access individual elements:

<pre>
var element = document.getElementById('map');
var element = document.querySelector('#map');
  // returns nodelist:
var elements = document.querySelectorAll('ul > li.active');
</pre>

The '''querySelector''' and '''querySelectorAll''' methods are often
superior to '''getElementById()''' and '''getElementsByClassName()''',
because CSS selectors allow you to access elements contextually. The
final line in the example above ignores otherwise matching
'''active'''-classed items that don't appear within '''ul''' lists.

==XXX MT CSS==

==Use Advanced CSS Formatting==

The Browser offers a high level of support for Level 3 CSS
properties, which offer a rich set of visual effects and layout
options.

This interactive utility demonstrates how various CSS properties work
together. After changing each property's value and seeing how it
affects an interface element, you can copy the resulting CSS syntax.

[[Image:media2.png]]

Information boxes feature summaries of key features, which are grouped
into related topics. Here's how more recent CSS features may help
improve a web app's appearance:

* '''Boxes:''' Block elements can appear with rounded corners and
shadows.  Interface elements can be positioned so they are ''fixed''
on the screen, while other interface elements may scroll freely.  The
''box-sizing'' property clarifies what part of a box to measure when
assigning its dimensions.

* '''Text:''' Letterforms may appear with shadows and blurs, and
their borders can be enhanced with outline effects to improve
legibility against different backgrounds. Text effects also apply to
any [[custom fonts]] you provide.

* '''Color:''' As an alternative to ''rgb'' color (or named colors
and hex values), the ''rgba'' color definition specifies an ''alpha''
value affecting the color's opacity. An alternative ''hsl'' model
specifies ''hue'', ''saturation'', and ''luminence''. Use ''hsla'' to
add an opacity value.  To fade entire elements rather than their
component colors, use the independent ''opacity'' property.

* '''Gradients:''' Gradients offer complex color definitions in
which colors fade from one part of an element to another or around a
point, with optional transitional states. (The Browser
supports both the W3C standard for gradients and legacy WebKit
syntax.)

* '''Masks:''' Masks allow you to modify how an image appears based
on the contents of another image, including a gradient, allowing you
to fade or clip portions of an image. Reflections produce a mirroring
effect, usually along with fading gradients.

* '''Backgrounds:''' Specify comma-separated values to assign more
than one background image, and affect related positioning and scaling
properties independently.  You can also assign a ''composite'' to
affect the appearance of background images based on the background
color.

* '''Borders:''' Flexible image components may appear in place of
borders. (The Browser supports both W3C standard syntax for border
images and legacy WebKit syntax.) You can also use the ''outline''
feature to assign an independent border without affecting an element's
dimensions.

* '''Overflow:''' When content overflows a box, you can provide
visual hints that more text is available, and control how long words
break within narrow columns. Overflowing content can be scrolled
automatically using a ''marquee'' animation, otherwise you can assign
your own custom scrollbar components.

* '''Columns:''' Create flexible multicolumn layouts, incorporating
elements that span columns and break multicolumn regions into separate
segments. Such layouts are most appropriate when [[deploying
alternative large-screen interfaces]], or in some cases for
[[landscape-oriented layouts]].

* '''Transitions:''' With CSS properties defining how different
application states appear, many properties can be set to animate from
one state to another. Supplying multiple comma-separated arguments
along with delays allows you to specify transitional sequences.  (See
[[Animations]] for more information.)

* '''Animations:''' Keyframe animations allow for more complex
animation sequences that can be applied more freely than transitions.
(For more information, see [[Animations]].)

* '''Transforms:''' Transforms allow you to move or modify the
appearance of elements by scaling, skewing, or rotating them.
Three-dimensional transforms allow you to control the viewer's
perceived position relative to an element, and place transformed
objects relative to others.  (For more information, see
[[Transforms]].)

* '''Flexbox:''' Flexible boxes offer a more abstract way to specify a
screen layout, often removing the need for various ''position'' and
''float'' options. Boxes can be ''oriented'' horizontally or
vertically to affect how child elements appear.  Along either axis,
the ''pack'' option allows you to center, distribute, or cluster
together child elements. The ''align'' option specifies how children
are then distributed along the perpendicular axis. Elements can appear
in a different order than how they are defined within the HTML markup,
reducing the need to modify the DOM.  Some elements can be resized to
fill any extra space.

* '''Interface:''' Updated CSS properties give control over whether
elements are draggable, editable, or selectable within HTML5-enabled
applications. You can also override the default ''appearance'' of
specialized interface elements such as [[form inputs]].

==Example: Freehand Drawings==

This example shows how to export a canvas drawing to a static image.
The interface allows you to make freehand drawings, modify the size
and color of the pen, and save each drawing to a series of images:

[[Image:canvas.png]]

In this case, the path follows a series of screen coordinates gathered
from [[touch handlers]]:

<pre>
cv.addEventListener('touchstart', function(e) {
    cx.moveTo(e.touches[0].offsetX, e.touches[0].offsetY);
    cx.beginPath();
});
cv.addEventListener('touchmove', function(e) {
    cx.lineTo(e.touches[0].offsetX, e.touches[0].offsetY);
    cx.stroke();
};
cv.addEventListener('touchend', function(e) {
    cx.closePath();
};
</pre>

The '''getImageData()''' method copies a rectangular selection from the
canvas, and '''putImageData''' replaces it. The '''canvas''' object's
'''toDataURL()''' method produces a static image specified with the
'''data:''' scheme, which can be referenced by an '''Image''' object's
'''src''' attribute.

<pre>
var width = maxX - minX; // tracked from touch gestures
var height = maxY - minY;
var img = new Image();
var data = cx.getImageData(minX, minY, width, height); // copy selection
cv.width = width; // clear  canvas
cv.height = height;
cx.putImageData(data, 0, 0); // replace selection at top left
img.src = cv.toDataURL(); // save into image
</pre>

==Example: Edit Irregular Selections==

The example above shows how to copy a canvas drawing into an image.
The following example shows how to read from an image into a canvas.
In this case, a freehand drawing gesture defines a clipping path,
after which tapping within the irregular selection extracts it from
the rest of the image:

[[Image:canvasfreeclip.png]]
[[Image:canvasfreeclip2.png]]

After the path is defined, a subsequent touch handler calls
'''isPointInPath()''' to test if screen coordinates fall within the
path.  The '''clip()''' method allows you to render subsequent
graphics only within the path. In this case, the '''drawImage()'''
method imports the image into the canvas, but only within the path:

<pre>
if (cx.isPointInPath(e.touches[0].offsetX, e.touches[0].offsetY) ) {
    cx.strokeStyle = 'transparent'; // erase selection color
    cx.stroke();
    cx.clip(); // set clipping region to path
    var img = new Image();
    img.src = 'img/Objects008.jpg';
    cx.drawImage(img,0,0); // redraw image into clipping region
}
</pre>

The '''rect()''' method also defines a path suitable for clipping. You
can use it to re-expand the path to the dimensions of the canvas:

<pre>
cx.rect(0, 0, cv.width, cv.height);
</pre>

